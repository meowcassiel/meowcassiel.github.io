---
layout: post
categories: 学习笔记
tags: ["Haskell", "《Real World Haskell》"]
title: 《Real World Haskell》 - ch4. 函数式编程
---

# 中缀函数

如果一个函数或构造器带两个或更多的参数，我们可以选择使用中缀形式，即我们把函数（名称）放在它的第一个和第二个参数之间。这允许我们把函数作为中缀操作符来使用。如：

```haskell
foo = Pair 1 2
bar = True `Pair` "quux"
```

# 列表常用函数

- ```length```。计算列表长度
- ```null```。判断列表是否为空
- ```head```。返回列表第一个元素。
- ```tail```。返回列表除去第一个元素外的其余部分
- ```last```。返回列表最后一个元素
- ```init```。返回列表除最后一个元素外的其余部分

> 以上函数中，有些不能直接应用在空列表上，会在运行时报错，如```head```。

- ```++```。拼接列表

- ```concat```。取一个包含列表的列表，这些列表中的元素具有相同的类型，它把这些列表连接在一起成为一个单一的列表

- ```reverse```。返回一个元素以相反的顺序排列的新列表

- ```and```。遍历列表，逻辑与。

- ```or```。遍历列表，逻辑或

- ```all```。比```and```多了一个谓词函数。

- ```any```。比```or```多了一个谓词函数。

- ```take```。返回一个由头k个元素组成的子列表

- ```drop```。丢掉列表开头的k个元素

- ```elem```。判断一个值是否出现在一个列表中

- ```filter```。接收一个谓词函数，返回列表中使谓词成功的每一个元素

- ```zip```。把两个列表压缩成一个单一的由二元组组成的列表。结果列表和被处理的两个列表中较短的那个等长

- ```zipWith```。带两个列表作为参数并为从每个列表中抽取一个元素而组成的二元组提供一个函数，最后生成与较短的那个列表等长的新列表。

- ```map```。接受一个函数和一个列表作为参数，将输入函数应用到输入列表的每个元素上，并构建出一个新的列表。

- ```foldl```，```foldr```。接受一个步骤（step）函数，一个累积器的初始化值，以及一个列表作为参数。步骤函数每次使用累积器和列表中的一个元素作为参数，并计算出新的累积器值，这个过程称为步进（stepper）。然后，将新的累积器作为参数，再次进行同样的计算，直到整个列表处理完为止。

  > 尽量使用```foldl'```代替```foldl```，防备出现因为过多未计算的表达式造成内存泄漏.

# 匿名（lambda）函数

在 Haskell 中，匿名函数以反斜杠符号 `\` 为开始，后跟函数的参数（可以包含模式），而函数体定义在 `->` 符号之后。其中， `\` 符号读作 *lambda* 。如：

```haskell
import Data.List (isInfixOf)

isInAny2 needle haystack = any (\s -> needle `isInfixOf` s) haystack
```

但要注意，普通函数可以通过多条语句来定义，而 lambda 函数的定义只能有一条语句。为了程序的可读性和可维护性考虑，我们在很多情况下都会避免使用 lambda 。

# 部分函数应用和柯里化

在 Haskell 中，*所有函数都只接受一个参数*。事实上，参数多于两个的函数都返回一个函数。

传入参数的数量，少于函数所能接受参数的数量，这种情况被称为函数的*部分应用*，又被称为柯里化（currying）。只要给部分函数补充上足够的参数，它就可以被成功求值。如：

```haskell
import Data.List (isInfixOf)

isInAny3 needle haystack = any (isInfixOf needle) haystack
```

# 节

使用括号包围一个操作符，通过在括号里面提供左操作对象或者右操作对象，可以产生一个部分应用函数。这种类型的部分函数应用称之为节（section）。如：

```haskell
import Data.List (isInfixOf)
isInAny4Partial needle = any (needle `isInfixOf`)
```

# As-模式

模式 `xs@(_:xs')` 被称为 as-模式，它的意思是：如果输入值能匹配 `@` 符号右边的模式（这里是 `(_:xs')` ），那么就将这个值绑定到 `@` 符号左边的变量中（这里是 `xs` ）。如：

```haskell
suffixes :: [a] -> [[a]]
suffixes xs@(_:xs') = xs : suffixes xs'
suffixes [] = []
```

除了增强可读性之外， as-模式还有其他作用：它可以对输入数据进行共享，而不是复制它。即重用匹配了 as-模式的输入值，因此就避免了内存分配。

# 组合函数

在任何时候，都可以通过使用 `(.)` 来组合函数，并产生新函数。组合链的长度并没有限制，只要 `(.)` 符号右边函数的输出值类型适用于 `(.)` 符号左边函数的输入值类型就可以了。

# 通过 seq 函数避免内存泄漏

```seq```强迫（force）求值传入的第一个参数，然后返回它的第二个参数。如：

```haskell
foldl' _ zero [] = zero
foldl' step zero (x:xs) = 
    let new = step zero x
    in new `seq` foldl' step new xs
```

注意，要正确地产生 `seq` 的作用，表达式中被求值的第一个必须是 `seq` 。

```haskell
-- 错误：因为表达式中第一个被求值的是 someFunc 而不是 seq
-- 所以 seq 的调用被隐藏了在 someFunc 调用之下
hiddenInside x y = someFunc (x `seq` y)

-- 错误：原因和上面一样
hiddenByLet x y z = let a = x `seq` someFunc y
                    in anotherFunc a z

-- 正确： seq 被第一个求值，并且 x 被强迫求值
onTheOutside x y = x `seq` someFunc y
```

`seq` 在遇到像数字这样的值时，它会对值进行求值，但是，一旦 `seq` 碰到构造器，比如 `(:)` 或者 `(,)` ，那么 `seq` 的求值就会停止。举个例子，如果将 `(1+2):[]` 传给 `seq` 作为它的第一个参数，那么 `seq` 不会对这个表达式进行求值；相反，如果将 `1` 传给 `seq` 作为第一个参数，那么它会被求值为 `1` 。